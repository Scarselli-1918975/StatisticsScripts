<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Server Attack Simulation</title>
    <style>
        body { text-align: center; }
        canvas { border: 1px solid black; margin-top: 20px; }
        #controls { margin-bottom: 20px; }
        #graphs { display: flex; justify-content: space-around; flex-wrap: wrap; }
    </style>
</head>
<body>
    <h1>Server Attack Simulation</h1>
    
    <div id="controls">
        <label for="numServers">Number of Servers (n):</label>
        <input id="numServers" type="number" value="30">
        <br>
        <label for="numAttackers">Number of Attackers (m):</label>
        <input id="numAttackers" type="number" value="20">
        <br>
        <label for="probability">Probability of Penetration (p):</label>
        <input id="probability" type="range" min="0" max="1" step="0.01" value="0.5" oninput="updateProbabilityDisplay()">
        <span id="probabilityValue">0.5</span>
        <br>
        <label for="lambda">Lambda (Expected Attacks):</label>
        <input id="lambda" type="number" value="5" step="0.1">
        <br>
        <label for="timeStep">Intermediate Distribution at Time Step (t*):</label>
        <input id="timeStep" type="number" value="15">
        <br>
        <button onclick="runSimulation()">Run Simulation</button>
    </div>

    <!-- Main trajectory graph -->
    <canvas id="simulationCanvas" width="800" height="400"></canvas>

    <!-- Distribution graphs -->
    <div id="graphs">
        <div>
            <h3>Intermediate Distribution (t*)</h3>
            <canvas id="intermediateDistributionCanvas" width="600" height="800"></canvas>
        </div>
        <div>
            <h3>Final Distribution</h3>
            <canvas id="finalDistributionCanvas" width="600" height="800"></canvas>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');

        const finalCanvas = document.getElementById('finalDistributionCanvas');
        const finalCtx = finalCanvas.getContext('2d');

        const intermediateCanvas = document.getElementById('intermediateDistributionCanvas');
        const intermediateCtx = intermediateCanvas.getContext('2d');

        function updateProbabilityDisplay() {
            document.getElementById('probabilityValue').innerText = document.getElementById('probability').value;
        }

        function runSimulation() {
            const numServers = parseInt(document.getElementById('numServers').value);
            const numAttackers = parseInt(document.getElementById('numAttackers').value);
            const probability = parseFloat(document.getElementById('probability').value);
            const lambda = parseFloat(document.getElementById('lambda').value);
            const timeStep = parseInt(document.getElementById('timeStep').value);

            let finalDistribution = Array(numServers * 2 + 1).fill(0);
            let intermediateDistribution = Array(numServers * 2 + 1).fill(0);

            const steps = numServers;  // Total time steps
            const numLevels = numServers * 2 + 1;

            let trajectories = [];
            let absoluteFrequencies = Array(steps + 1).fill(null).map(() => Array(numLevels).fill(0));

            // Clear canvases before drawing
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            finalCtx.clearRect(0, 0, finalCanvas.width, finalCanvas.height);
            intermediateCtx.clearRect(0, 0, intermediateCanvas.width, intermediateCanvas.height);

            // Calculate max and min penetration values dynamically
            let maxY = 0;  // We no longer have negative values

            // Simulate trajectories
            for (let attacker = 0; attacker < numAttackers; attacker++) {
                let y = 0;  // Start at 0 penetrations
                let trajectory = [y];  // Start every attacker at zero at time step 0

                for (let step = 1; step <= steps; step++) {
                    // Use lambda to simulate possible jumps in attack success, combined with p for attack direction
                    let change = (Math.random() < lambda / numServers) ? 1 : 0;  // Lambda controls attack jumps
                    let verticalStep = (Math.random() < probability) ? change : -change; // Adjust direction by p
                    y += verticalStep;
                    if (y < 0) y = 0;  // Ensure no negative penetration
                    trajectory.push(y);  // Store trajectory for the current step

                    // Update max penetration value
                    if (y > maxY) maxY = y;

                    // Track absolute frequency at each step
                    absoluteFrequencies[step][y]++;
                }

                trajectories.push(trajectory);
            }

            // Calculate final distribution
            for (let attacker = 0; attacker < numAttackers; attacker++) {
                let finalValue = trajectories[attacker][steps];
                finalDistribution[finalValue]++;
            }

            // Calculate intermediate distribution at selected step
            let selectedStep = Math.min(timeStep, steps);
            for (let attacker = 0; attacker < numAttackers; attacker++) {
                let intermediateValue = trajectories[attacker][selectedStep];
                intermediateDistribution[intermediateValue]++;
            }

            // Draw axes with adjusted scaling (only positive values)
            drawAxes(ctx, canvas, steps, maxY);

            // Draw each attacker's trajectory
            for (let attacker = 0; attacker < numAttackers; attacker++) {
                drawTrajectory(trajectories[attacker], steps, maxY);
            }

            // Draw the final and intermediate distributions on separate canvases
            drawHistogram(intermediateCtx, intermediateCanvas, intermediateDistribution, numServers, "red", selectedStep, maxY);
            drawHistogram(finalCtx, finalCanvas, finalDistribution, numServers, "blue", steps, maxY);
        }

        // Function to draw trajectories without negative values
        function drawTrajectory(trajectory, steps, maxY) {
            const margin = 50;
            const stepSizeX = (canvas.width - margin * 2) / steps;  // Adaptive horizontal step size
            const stepSizeY = (canvas.height - margin * 2) / maxY;  // Adaptive vertical step size

            let x = margin;  // Initial x-coordinate
            let y = canvas.height - margin;  // Start at zero (bottom of the canvas)

            ctx.beginPath();
            ctx.moveTo(x, y);  // Start from zero at step 0 for every attacker

            // Model from step 0 onwards
            for (let step = 0; step <= steps; step++) {
                y = canvas.height - margin - (trajectory[step] * stepSizeY);  // Scale y based on trajectory value

                ctx.lineTo(x, y);
                ctx.stroke();
                x += stepSizeX;
                ctx.lineTo(x, y);
                ctx.stroke();
            }

            ctx.strokeStyle = getRandomColor();
            ctx.stroke();
        }

        function drawAxes(ctx, canvas, steps, maxY) {
            const margin = 50;
            const axisColor = "#000000";
            const axisWidth = 2;

            ctx.strokeStyle = axisColor;
            ctx.lineWidth = axisWidth;

            // Draw Y-axis (Only positive values now)
            ctx.beginPath();
            ctx.moveTo(margin, 0);
            ctx.lineTo(margin, canvas.height - margin);
            ctx.stroke();

            // Draw X-axis at the bottom
            ctx.beginPath();
            ctx.moveTo(margin, canvas.height - margin);
            ctx.lineTo(canvas.width, canvas.height - margin);
            ctx.stroke();

            ctx.lineWidth = 1;
            ctx.strokeStyle = "#000000"; // Ensure the tick marks and labels are black

            // Draw X-axis ticks and labels (Time Steps)
            const stepSizeX = (canvas.width - margin * 2) / steps;
            for (let i = 0; i <= steps; i++) {
                let x = margin + i * stepSizeX;
                ctx.beginPath();
                ctx.moveTo(x, canvas.height - margin - 5);
                ctx.lineTo(x, canvas.height - margin + 5);
                ctx.stroke();

                ctx.fillText(i, x - 5, canvas.height - margin + 20);  // Display step label under tick mark
            }

            // Draw Y-axis ticks and labels (Penetration Levels)
            const stepSizeY = (canvas.height - margin * 2) / maxY;
            for (let i = 0; i <= maxY; i++) {
                let y = canvas.height - margin - i * stepSizeY;
                ctx.beginPath();
                ctx.moveTo(margin - 5, y);
                ctx.lineTo(margin + 5, y);
                ctx.stroke();

                ctx.fillText(i, margin - 25, y + 5);  // Display level label beside tick mark
            }
        }

        // Function to draw histograms
        function drawHistogram(ctx, canvas, distribution, numServers, color, step, maxY) {
            const margin = 50;
            const barWidth = (canvas.width - margin * 2) / (distribution.length - 1);
            const maxCount = Math.max(...distribution);
            const scalingFactor = (canvas.height - margin * 2) / maxCount;

            ctx.fillStyle = color;

            for (let i = 0; i < distribution.length; i++) {
                const barHeight = distribution[i] * scalingFactor;
                const x = margin + i * barWidth;
                const y = canvas.height - margin - barHeight;

                ctx.fillRect(x, y, barWidth - 1, barHeight);  // Draw bars
            }
        }

        // Function to generate a random color for each attacker trajectory
        function getRandomColor() {
            return `hsl(${Math.random() * 360}, 100%, 50%)`;
        }
    </script>
</body>
</html>
